/**
 * Project Writer
 * Handles file system operations for creating project structures
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class ProjectWriter {
  constructor(logger = null) {
    this.logger = logger;
    this.projectsPath = process.env.PROJECTS_PATH || path.join(__dirname, "../../projects");
  }

  /**
   * Initialize projects directory
   */
  initializeProjectsDir() {
    try {
      if (!fs.existsSync(this.projectsPath)) {
        fs.mkdirSync(this.projectsPath, { recursive: true });
        this.logger?.info({ path: this.projectsPath }, "Projects directory created");
      }
      return this.projectsPath;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to initialize projects directory");
      throw err;
    }
  }

  /**
   * Create a new project directory
   */
  createProjectDirectory(projectName) {
    try {
      const projectPath = path.join(this.projectsPath, projectName);
      
      if (fs.existsSync(projectPath)) {
        throw new Error(`Project directory already exists: ${projectPath}`);
      }

      fs.mkdirSync(projectPath, { recursive: true });
      this.logger?.info({ projectName, projectPath }, "Project directory created");
      
      return projectPath;
    } catch (err) {
      this.logger?.error({ error: err.message, projectName }, "Failed to create project directory");
      throw err;
    }
  }

  /**
   * Write a file to the project
   */
  writeFile(projectPath, filePath, content) {
    try {
      const fullPath = path.join(projectPath, filePath);
      const dirPath = path.dirname(fullPath);

      // Create directory structure if it doesn't exist
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      fs.writeFileSync(fullPath, content, "utf8");
      this.logger?.debug({ filePath, size: content.length }, "File written");
      
      return fullPath;
    } catch (err) {
      this.logger?.error({ error: err.message, filePath }, "Failed to write file");
      throw err;
    }
  }

  /**
   * Write multiple files at once
   */
  writeFiles(projectPath, files) {
    try {
      const results = [];

      for (const [filePath, content] of Object.entries(files)) {
        const fullPath = this.writeFile(projectPath, filePath, content);
        results.push({ filePath, fullPath, status: "success" });
      }

      this.logger?.info({ fileCount: results.length, projectPath }, "Files written");
      return results;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to write files");
      throw err;
    }
  }

  /**
   * Create package.json
   */
  createPackageJson(projectPath, config) {
    try {
      const packageJson = {
        name: config.name || "untitled-project",
        version: config.version || "1.0.0",
        description: config.description || "Generated by Genie",
        main: config.main || "src/index.js",
        type: "module",
        scripts: {
          start: config.startScript || "node src/index.js",
          dev: config.devScript || "node --watch src/index.js",
          test: config.testScript || "echo 'No tests specified'",
          build: config.buildScript || "echo 'No build script'",
          ...config.scripts
        },
        keywords: config.keywords || ["genie", "generated"],
        author: config.author || "Genie AI",
        license: config.license || "MIT",
        dependencies: config.dependencies || {},
        devDependencies: config.devDependencies || {}
      };

      const content = JSON.stringify(packageJson, null, 2);
      this.writeFile(projectPath, "package.json", content);
      
      this.logger?.info({ projectPath }, "package.json created");
      return packageJson;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to create package.json");
      throw err;
    }
  }

  /**
   * Create README.md
   */
  createReadme(projectPath, config) {
    try {
      const demoSection = config.demoMode ? `

## Demo Mode

This project includes a working prototype/demo that you can run immediately after installation.

\`\`\`bash
npm install
npm start
\`\`\`

The demo includes:
- Working example functionality
- Sample data and endpoints (if backend)
- Interactive UI (if frontend)
- Browser-ready features (if web app)

Try the demo to see the project in action!
` : "";

      const readme = `# ${config.name || "Untitled Project"}

${config.description || ""}

## Quick Start

\`\`\`bash
npm install
npm start
\`\`\`

## Development

For development with auto-reload:

\`\`\`bash
npm run dev
\`\`\`

## Project Structure

${config.structure || ""}
${demoSection}

## Generated by Genie

This project was automatically generated by Genie - the multi-LLM consensus AI system.
`;

      this.writeFile(projectPath, "README.md", readme);
      
      this.logger?.info({ projectPath, demoMode: config.demoMode }, "README.md created");
      return readme;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to create README");
      throw err;
    }
  }

  /**
   * Create .gitignore
   */
  createGitignore(projectPath) {
    try {
      const gitignore = `node_modules/
.env
.env.local
.DS_Store
*.log
dist/
build/
.vscode/
.idea/
`;

      this.writeFile(projectPath, ".gitignore", gitignore);
      
      this.logger?.info({ projectPath }, ".gitignore created");
      return gitignore;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to create .gitignore");
      throw err;
    }
  }

  /**
   * Get project path
   */
  getProjectPath(projectName) {
    return path.join(this.projectsPath, projectName);
  }

  /**
   * List all projects
   */
  listProjects() {
    try {
      if (!fs.existsSync(this.projectsPath)) {
        return [];
      }

      const projects = fs.readdirSync(this.projectsPath)
        .filter(name => {
          const fullPath = path.join(this.projectsPath, name);
          return fs.statSync(fullPath).isDirectory();
        });

      return projects;
    } catch (err) {
      this.logger?.error({ error: err.message }, "Failed to list projects");
      return [];
    }
  }

  /**
   * Get project info
   */
  getProjectInfo(projectName) {
    try {
      const projectPath = this.getProjectPath(projectName);
      
      if (!fs.existsSync(projectPath)) {
        return null;
      }

      const stats = fs.statSync(projectPath);
      const packageJsonPath = path.join(projectPath, "package.json");
      
      let packageJson = null;
      if (fs.existsSync(packageJsonPath)) {
        const content = fs.readFileSync(packageJsonPath, "utf8");
        packageJson = JSON.parse(content);
      }

      return {
        name: projectName,
        path: projectPath,
        created: stats.birthtime,
        modified: stats.mtime,
        packageJson
      };
    } catch (err) {
      this.logger?.error({ error: err.message, projectName }, "Failed to get project info");
      return null;
    }
  }
}

export default ProjectWriter;
